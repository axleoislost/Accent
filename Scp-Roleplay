pcall(function()
   if getgenv().AccentLoaded then return end
	local function randomString(length)
			local charset = {}
			for i = 48, 57 do table.insert(charset, string.char(i)) end 
			for i = 65, 90 do table.insert(charset, string.char(i)) end 
			for i = 97, 122 do table.insert(charset, string.char(i)) end 

			local str = {}
			for i = 1, length do
				str[i] = charset[math.random(1, #charset)]
			end
			return table.concat(str)
	end

		local RunService = game:GetService("RunService")
		local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/axleoislost/Rayfield/refs/heads/main/Rayfield.lua'))()
		local k = Color3.fromRGB
		local Window = Rayfield:CreateWindow({
		Name = "Accent || Scp Roleplay || v1.1.1",
		Icon = 0,
		LoadingTitle = "Loading ...",
		LoadingSubtitle = "By axleoislost",
		Theme = {
			Shadow = k(0,0,0), SliderProgress = k(93,63,192), PlaceholderColor = k(77,77,77),
			InputStroke = k(200,200,200), ToggleDisabledStroke = k(130,130,130), InputBackground = k(30,30,30),
			ElementBackgroundHover = k(33,33,33), DropdownUnselected = k(30,30,30), SelectedTabTextColor = k(210,210,210),
			NotificationBackground = k(25,25,25), DropdownSelected = k(40,40,40), SecondaryElementStroke = k(40,40,40),
			Background = k(15,15,15), ToggleDisabledOuterStroke = k(65,65,65), TabStroke = k(61,61,61),
			ElementBackground = k(28,28,28), ToggleEnabledOuterStroke = k(79,79,79), ToggleEnabled = k(93,63,192),
			ToggleEnabledStroke = k(69,69,69), ToggleDisabled = k(100,100,100), SecondaryElementBackground = k(25,25,25),
			ToggleBackground = k(23,23,23), TabTextColor = k(240,240,240), ElementStroke = k(46,46,46),
			SliderBackground = k(23,23,23), SliderStroke = k(84,84,84), NotificationActionsBackground = k(230,230,230),
			Topbar = k(20,20,20), TabBackground = k(56,56,56), TabBackgroundSelected = k(105,90,205),
			TextColor = k(240,240,240),
		},
		DisableRayfieldPrompts = false,
		DisableBuildWarnings = false,
		ConfigurationSaving = {
			Enabled = false,
			FolderName = nil,
			FileName = "NullZen Configs"
		},
		Discord = {
			Enabled = false,
			Invite = "noinvitelink",
			RememberJoins = true
		},
		KeySystem = false,
		KeySettings = {
			Title = "Accent || Key System || v1.0.5",
			Subtitle = "discord.gg/WGhq4kBAG3",
			Note = "Link to get key copied to clipboard",
			FileName = "Key",
			SaveKey = true,
			GrabKeyFromSite = false,
			Key =  {"toilet"}
		}
		})

        local Main = Window:CreateTab("Home","home")
        local Section = Main:CreateSection("Options")

        local connection, vidGui, videoFrame

        local Toggle = Main:CreateToggle({
            Name = "gay niggas kissing",
            CurrentValue = false,
            Flag = "Toggle1",
            Callback = function(Value)
                if Value then
                    pcall(function()
                        if not writefile or not readfile or not getcustomasset or not game.HttpGet then return end

                        local videofile = "gayniggas.webm"
                        local videolink = "https://cdn.discordapp.com/attachments/1377917831206932480/1395097630182477905/gay_niggas_kissing.mp4?ex=6879356a&is=6877e3ea&hm=ea683006bb5f55f508d21bce49d3163e2b037f0da788fe10a8e1685d72aafd50"

                        if not pcall(readfile, videofile) then
                            local videoData = game:HttpGet(videolink)
                            writefile(videofile, videoData)
                        end

                        local cloneref = cloneref or function(o) return o end
                        local coregui = cloneref(game:GetService("CoreGui"))

                        vidGui = Instance.new("ScreenGui")
                        vidGui.Name = "videoGui"
                        vidGui.ResetOnSpawn = false
                        vidGui.IgnoreGuiInset = true
                        vidGui.Parent = coregui

                        videoFrame = Instance.new("VideoFrame")
                        videoFrame.BackgroundTransparency = 1
                        videoFrame.Size = UDim2.new(0, 400, 0, 300)
                        videoFrame.Position = UDim2.new(0, 100, 0, 100)
                        videoFrame.Looped = true
                        videoFrame.Video = getcustomasset(videofile)
                        videoFrame.Parent = vidGui
                        videoFrame:Play()

                        local velocity = Vector2.new(160, 150)
                        local position = Vector2.new(100, 100)
                        local RunService = game:GetService("RunService")

                        connection = RunService.Heartbeat:Connect(function(dt)
                            local screenSize = workspace.CurrentCamera.ViewportSize
                            local size = Vector2.new(videoFrame.AbsoluteSize.X, videoFrame.AbsoluteSize.Y)
                            position = position + velocity * dt

                            if position.X <= 0 then
                                position = Vector2.new(0, position.Y)
                                velocity = Vector2.new(math.abs(velocity.X), velocity.Y)
                            elseif position.X + size.X >= screenSize.X then
                                position = Vector2.new(screenSize.X - size.X, position.Y)
                                velocity = Vector2.new(-math.abs(velocity.X), velocity.Y)
                            end
                            if position.Y <= 0 then
                                position = Vector2.new(position.X, 0)
                                velocity = Vector2.new(velocity.X, math.abs(velocity.Y))
                            elseif position.Y + size.Y >= screenSize.Y then
                                position = Vector2.new(position.X, screenSize.Y - size.Y)
                                velocity = Vector2.new(velocity.X, -math.abs(velocity.Y))
                            end

                            videoFrame.Position = UDim2.new(0, position.X, 0, position.Y)
                        end)
                    end)
                else
                    pcall(function()
                        if connection then
                            connection:Disconnect()
                            connection = nil
                        end
                        if vidGui then
                            vidGui.Enabled = false
                            vidGui:Destroy()
                            vidGui = nil
                        end
                        if videoFrame then
                            videoFrame:Pause()
                            videoFrame.Visible = false
                            videoFrame = nil
                        end
                    end)
                end
            end,
        })




		local AntiAfkToggle = Main:CreateToggle({
			Name = "Anti AFK",
			CurrentValue = false,
			Flag = "AntiAfkToggle",
			Callback = function(Value)
					pcall(function()
						local vu = game:GetService("VirtualUser")
						game:GetService("Players").LocalPlayer.Idled:connect(function()
						vu:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
						wait(1)
						vu:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
					end)
				end)
			end,
		})

		local FullBrightToggle = Main:CreateToggle({
			Name = "Full Bright",
			CurrentValue = false,
			Flag = "FullBright",
			Callback = function(Value)
				FullBrightEnabled = Value
				if FullBrightEnabled then
					coroutine.wrap(function()
						while FullBrightEnabled do
							game:GetService("Lighting").Ambient = Color3.new(1.39, 1.39, 1.39)
							task.wait(0.1)
						end
					end)()
				else
					game:GetService("Lighting").Ambient = Color3.new(0, 0, 0)
				end
			end,
		})

		local player = game.Players.LocalPlayer
		local NoclipEnabled = false
		local connection

		connection = player.CharacterAdded:Connect(function(character)
			task.wait(0.1)
			if NoclipEnabled then
				for _, part in pairs(character:GetDescendants()) do
					if part:IsA("BasePart") then
						part.CanCollide = false
					end
				end
			end
		end)

		local NoclipToggle = Main:CreateToggle({
			Name = "Noclip",
			CurrentValue = false,
			Flag = "Noclip",
			Callback = function(Value)
				NoclipEnabled = Value

				if NoclipEnabled then
					coroutine.wrap(function()
						while NoclipEnabled do
							pcall(function()
								local character = player.Character
								if character and character.Parent then
									for _, part in pairs(character:GetDescendants()) do
										if part:IsA("BasePart") then
											part.CanCollide = false
										end
									end
								end
							end)
							task.wait(0.2)
						end
					end)()
				else
					local character = player.Character
					if character and character.Parent then
						for _, part in pairs(character:GetDescendants()) do
							if part:IsA("BasePart") then
								part.CanCollide = true
							end
						end
					end
				end
			end,
		})




		local isenabled = false

		local AntiVoidToggle = Main:CreateToggle({
		Name = "Anti Void",
		CurrentValue = false,
		Flag = "AntiVoidToggle", 
		Callback = function(Value)
			isenabled = Value

			if Value then
			   pcall(function()
				local player = game.Players.LocalPlayer
				local checkInterval = 0.1
				local partSize = Vector3.new(4, 1, 4)
				local partColor = Color3.new(1, 0, 0)
				local spawnedParts = {}
				local debounce = 0
				local heartbeatConnection

				player.CharacterAdded:Connect(function(character)
					local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

					if heartbeatConnection then
						heartbeatConnection:Disconnect()
					end

					heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
						debounce = debounce + deltaTime
						if debounce >= checkInterval then
							debounce = 0
							if isenabled then
								local ray = Ray.new(humanoidRootPart.Position, Vector3.new(0, -1000, 0))
								local hitPart, hitPosition = workspace:FindPartOnRay(ray, player.Character)

								if not hitPart then
									local part = Instance.new("Part")
									part.Size = partSize
									part.Position = humanoidRootPart.Position - Vector3.new(0, partSize.Y / 2 + 1, 0)
									part.Anchored = true
									part.CanCollide = true
									part.BrickColor = BrickColor.new(partColor)
									part.Transparency = 1
									part.Parent = workspace
									table.insert(spawnedParts, part)

									local isStandingOnPart = false
									while not isStandingOnPart do
										wait(0.1)
										if humanoidRootPart.Position.Y <= part.Position.Y + partSize.Y / 2 then
											isStandingOnPart = true
										end
									end
									part:Destroy()
								end
							end
						end
					end)
				end)

				if player.Character then
					local humanoidRootPart = player.Character:WaitForChild("HumanoidRootPart")
					if not heartbeatConnection then
						heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
							debounce = debounce + deltaTime
							if debounce >= checkInterval then
								debounce = 0
								if isenabled then
									local ray = Ray.new(humanoidRootPart.Position, Vector3.new(0, -1000, 0))
									local hitPart, hitPosition = workspace:FindPartOnRay(ray, player.Character)

									if not hitPart then
										local part = Instance.new("Part")
										part.Size = partSize
										part.Position = humanoidRootPart.Position - Vector3.new(0, partSize.Y / 2 + 1, 0)
										part.Anchored = true
										part.CanCollide = true
										part.BrickColor = BrickColor.new(partColor)
										part.Transparency = 1
										part.Parent = workspace
										table.insert(spawnedParts, part)

										local isStandingOnPart = false
										while not isStandingOnPart do
											wait(0.1)
											if humanoidRootPart.Position.Y <= part.Position.Y + partSize.Y / 2 then
												isStandingOnPart = true
											end
										end
										part:Destroy()
									end
								end
							end
						end)
					end
				end
              end)
			else
				if heartbeatConnection then
					heartbeatConnection:Disconnect()
				end
			end
		end,
		})


		local speedBoostEnabled = true
		local currentBoostAmount = 0
		local heartbeatConnection
		local runningConnection
		local walkSpeedMonitorThread

		local player = game.Players.LocalPlayer
		local runService = game:GetService("RunService")

		player.CharacterAdded:Connect(function(character)
			local humanoid = character:WaitForChild("Humanoid")

			if heartbeatConnection then
				heartbeatConnection:Disconnect()
			end
			if runningConnection then
				runningConnection:Disconnect()
			end

			local boosting = false

			heartbeatConnection = runService.Heartbeat:Connect(function()
				if boosting and speedBoostEnabled then
					local delta = humanoid.MoveDirection * currentBoostAmount
                    if character then
                        pcall(function()
					    character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame + delta)
                    end)
                    end
				end
			end)

			runningConnection = humanoid.Running:Connect(function(speed)
				boosting = humanoid.MoveDirection.Magnitude > 0
			end)
		end)

		if player.Character then
			local character = player.Character
			local humanoid = character:WaitForChild("Humanoid")

			if heartbeatConnection then
				heartbeatConnection:Disconnect()
			end
			if runningConnection then
				runningConnection:Disconnect()
			end

			local boosting = false

			heartbeatConnection = runService.Heartbeat:Connect(function()
				if boosting and speedBoostEnabled then
					local delta = humanoid.MoveDirection * currentBoostAmount
                    if character then
                    pcall(function()
					character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame + delta)
                    end)
                    end
				end
			end)

			runningConnection = humanoid.Running:Connect(function(speed)
				boosting = humanoid.MoveDirection.Magnitude > 0
			end)
		end

		local SpeedBoostSliderN = Main:CreateSlider({
			Name = "Speed Boost",
			Range = {0, 0.45},
			Increment = 0.01,
			Suffix = "Boost",
			CurrentValue = 0,
			Flag = "SpeedBoostSlider",
			Callback = function(Value)
				currentBoostAmount = Value
                pcall(function()
				if player.Character then
					local character = player.Character
					local humanoid = character:FindFirstChild("Humanoid")
					if humanoid then
						if heartbeatConnection then
							heartbeatConnection:Disconnect()
						end
						if runningConnection then
							runningConnection:Disconnect()
						end

						local boosting = false

						heartbeatConnection = runService.Heartbeat:Connect(function()
							if boosting and speedBoostEnabled then
								local delta = humanoid.MoveDirection * currentBoostAmount
                                if character then
                                pcall(function()
								 character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame + delta)
                                end)
                                end
							end
						end)

						runningConnection = humanoid.Running:Connect(function(speed)
							boosting = humanoid.MoveDirection.Magnitude > 0
						end)
					end
				end

				if walkSpeedMonitorThread then
					walkSpeedMonitorThread:Disconnect()
					walkSpeedMonitorThread = nil
				end

				if Value > 0.3 then
					walkSpeedMonitorThread = runService.Heartbeat:Connect(function()
						local character = player.Character
						if character and character:FindFirstChild("Humanoid") then
							character.Humanoid.WalkSpeed = 14
						end
					end)
				end
				end)
			end,
		})


		local Players = game:GetService("Players")
		local StarterGui = game:GetService("StarterGui")

		Main:CreateToggle({
			Name = "Show Full Chat",
			CurrentValue = false,
			Flag = "Toggle1",
			Callback = function(Value)
				game:GetService("TextChatService").ChatWindowConfiguration.Enabled = Value
			end,
		})

		local ESPEnabledz = false
		local ESPBoxes = {}
		local Tracers = {}
		local NameGuis = {}
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local Camera = workspace.CurrentCamera
		local LocalPlayer = Players.LocalPlayer


		local lineThickness = 2
		local tracerThickness = 1.5
		local wallGap = 0

		local SCPESPToggle = Main:CreateToggle({ 
			Name = "SCP ESP",
			CurrentValue = false,
			Flag = "Toggle1",
			Callback = function(Value)
				ESPEnabledz = Value
				pcall(function()

				if ESPEnabledz then
				local SCPFolder = workspace:WaitForChild("SCPs")
					local distanceUpdater = coroutine.create(function()
						while ESPEnabledz do
							for scp, gui in pairs(NameGuis) do
								if scp and gui and gui:FindFirstChildOfClass("TextLabel") then
									local nameLabel = gui:FindFirstChildOfClass("TextLabel")
									local humanoidRootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
									if humanoidRootPart and scp.PrimaryPart then
										local dist = (humanoidRootPart.Position - scp.PrimaryPart.Position).Magnitude
										nameLabel.Text = scp.Name .. ", " .. string.format("%.0f", dist)
									else
										nameLabel.Text = scp.Name .. ", ???"
									end
								end
							end
							wait(0.15)
						end
					end)
					coroutine.resume(distanceUpdater)

					spawn(function()
						while ESPEnabledz do
							for scp, box in pairs(ESPBoxes) do
								for _, line in pairs(box) do
									if line and line.Visible then
										line.Visible = false
										line:Remove()
									end
								end
							end
							ESPBoxes = {}

							for scp, tracer in pairs(Tracers) do
								if tracer and tracer.Visible then
									tracer.Visible = false
									tracer:Remove()
								end
							end
							Tracers = {}

							for scp, gui in pairs(NameGuis) do
								if gui then gui:Destroy() end
							end
							NameGuis = {}

							for _, scp in pairs(SCPFolder:GetChildren()) do
								if scp:IsA("Model") then
									local box = {
										Top = Drawing.new("Line"),
										Bottom = Drawing.new("Line"),
										Left = Drawing.new("Line"),
										Right = Drawing.new("Line")
									}
									for _, line in pairs(box) do
										line.Thickness = lineThickness
										line.Transparency = 1
										line.ZIndex = 1
										line.Color = Color3.new(1, 0, 0)
										line.Visible = true
									end
									ESPBoxes[scp] = box

									local tracer = Drawing.new("Line")
									tracer.Thickness = tracerThickness
									tracer.Transparency = 1
									tracer.ZIndex = 1
									tracer.Color = Color3.new(1, 0, 0)
									tracer.Visible = true
									Tracers[scp] = tracer

									local billboardGui = Instance.new("BillboardGui")
									billboardGui.Name = "SCPNameGui"
									billboardGui.Parent = scp
									billboardGui.Adornee = scp.PrimaryPart or scp:FindFirstChildWhichIsA("BasePart")
									billboardGui.Size = UDim2.new(0, 100, 0, 50)
									billboardGui.StudsOffset = Vector3.new(0, 5, 0)
									billboardGui.AlwaysOnTop = true
									billboardGui.LightInfluence = 0

									local nameLabel = Instance.new("TextLabel")
									nameLabel.Parent = billboardGui
									nameLabel.Size = UDim2.new(1, 0, 1, 0)
									nameLabel.BackgroundTransparency = 1
									nameLabel.TextColor3 = Color3.new(1, 1, 1)
									nameLabel.TextScaled = true
									nameLabel.Font = Enum.Font.SourceSansBold
									nameLabel.Text = scp.Name .. ", ???" 

									NameGuis[scp] = billboardGui
								end
							end

							local startTime = tick()
							while ESPEnabledz and tick() - startTime < 8 do
								for scp, box in pairs(ESPBoxes) do
									if scp and scp.PrimaryPart then
										local cf = scp.PrimaryPart.CFrame
										local size = scp:GetExtentsSize()

										local corners = {
											cf * Vector3.new(-size.X/2, size.Y/2, -size.Z/2),
											cf * Vector3.new(size.X/2, size.Y/2, -size.Z/2),
											cf * Vector3.new(size.X/2, size.Y/2, size.Z/2),
											cf * Vector3.new(-size.X/2, size.Y/2, size.Z/2),
											cf * Vector3.new(-size.X/2, -size.Y/2, -size.Z/2),
											cf * Vector3.new(size.X/2, -size.Y/2, -size.Z/2),
											cf * Vector3.new(size.X/2, -size.Y/2, size.Z/2),
											cf * Vector3.new(-size.X/2, -size.Y/2, size.Z/2),
										}

										local screenCorners = {}
										local onScreen = true
										for i, corner in pairs(corners) do
											local screenPos, visible = Camera:WorldToViewportPoint(corner)
											if not visible then onScreen = false end
											screenCorners[i] = Vector2.new(screenPos.X, screenPos.Y)
										end

										if onScreen then
											local topLeft = Vector2.new(math.huge, math.huge)
											local bottomRight = Vector2.new(-math.huge, -math.huge)

											for _, sc in pairs(screenCorners) do
												if sc.X < topLeft.X then topLeft = Vector2.new(sc.X, topLeft.Y) end
												if sc.Y < topLeft.Y then topLeft = Vector2.new(topLeft.X, sc.Y) end

												if sc.X > bottomRight.X then bottomRight = Vector2.new(sc.X, bottomRight.Y) end
												if sc.Y > bottomRight.Y then bottomRight = Vector2.new(bottomRight.X, sc.Y) end
											end

											box.Top.From = Vector2.new(topLeft.X, topLeft.Y)
											box.Top.To = Vector2.new(bottomRight.X, topLeft.Y)
											box.Top.Visible = true

											box.Bottom.From = Vector2.new(topLeft.X, bottomRight.Y)
											box.Bottom.To = Vector2.new(bottomRight.X, bottomRight.Y)
											box.Bottom.Visible = true

											box.Left.From = Vector2.new(topLeft.X, topLeft.Y)
											box.Left.To = Vector2.new(topLeft.X, bottomRight.Y)
											box.Left.Visible = true

											box.Right.From = Vector2.new(bottomRight.X, topLeft.Y)
											box.Right.To = Vector2.new(bottomRight.X, bottomRight.Y)
											box.Right.Visible = true

											local screenCenterX = Camera.ViewportSize.X / 2
											local bottomCenterScreen = Vector2.new(screenCenterX, Camera.ViewportSize.Y)

											local bottomCenter3D = (corners[5] + corners[6] + corners[7] + corners[8]) / 4
											local screenBottomCenter, visible2 = Camera:WorldToViewportPoint(bottomCenter3D)

											if visible2 then
												Tracers[scp].From = bottomCenterScreen
												Tracers[scp].To = Vector2.new(screenBottomCenter.X, screenBottomCenter.Y)
												Tracers[scp].Visible = true
											else
												Tracers[scp].Visible = false
											end

										else
											for _, line in pairs(box) do
												line.Visible = false
											end
											if Tracers[scp] then
												Tracers[scp].Visible = false
											end
										end
									else
										if ESPBoxes[scp] then
											for _, line in pairs(ESPBoxes[scp]) do
												if line.Visible then
													line.Visible = false
													line:Remove()
												end
											end
											ESPBoxes[scp] = nil
										end
										if Tracers[scp] then
											if Tracers[scp].Visible then
												Tracers[scp].Visible = false
												Tracers[scp]:Remove()
											end
											Tracers[scp] = nil
										end
										if NameGuis[scp] then
											NameGuis[scp]:Destroy()
											NameGuis[scp] = nil
										end
									end
								end
                                wait(0.03)
							end
						end
						ESPEnabledz = false
					end)
				else
					for scp, box in pairs(ESPBoxes) do
						for _, line in pairs(box) do
							if line and line.Visible then
								line.Visible = false
								line:Remove()
							end
						end
					end
					ESPBoxes = {}

					for scp, tracer in pairs(Tracers) do
						if tracer and tracer.Visible then
							tracer.Visible = false
							tracer:Remove()
						end
					end
					Tracers = {}

					for scp, gui in pairs(NameGuis) do
						if gui then gui:Destroy() end
					end
					NameGuis = {}
				end
				end)
			end,
		})


		local UserInputService = game:GetService("UserInputService")
		local player = game.Players.LocalPlayer
		local infJumpConnection
		local infJumpDebounce = false
		local jumpPowerEnforcer

		local InfiniteJumpToggle = Main:CreateToggle({
			Name = "Infinite Jump",
			CurrentValue = false,
			Flag = "InfiniteJumpToggle",
			Callback = function(Value)
			pcall(function()
				if Value then
					if infJumpConnection then infJumpConnection:Disconnect() end
					infJumpDebounce = false
					infJumpConnection = UserInputService.JumpRequest:Connect(function()
						if not infJumpDebounce and player.Character then
							local humanoid = player.Character:FindFirstChildWhichIsA("Humanoid")
							if humanoid then
								infJumpDebounce = true
								humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
								task.wait()
								infJumpDebounce = false
							end
						end
					end)

					if jumpPowerEnforcer then
						jumpPowerEnforcer:Disconnect()
					end
					jumpPowerEnforcer = RunService.RenderStepped:Connect(function()
						local character = player.Character
						if character then
							local humanoid = character:FindFirstChildWhichIsA("Humanoid")
							if humanoid and humanoid.JumpPower ~= 50 then
								humanoid.JumpPower = 50
							end
						end
					end)

				else
					if infJumpConnection then
						infJumpConnection:Disconnect()
						infJumpConnection = nil
					end
					infJumpDebounce = false

					if jumpPowerEnforcer then
						jumpPowerEnforcer:Disconnect()
						jumpPowerEnforcer = nil
					end
				end
				end)
			end,
		})

		local UserInputService = game:GetService("UserInputService")
		local Players = game:GetService("Players")

		local player = Players.LocalPlayer
		local camera = workspace.CurrentCamera

		local flying = false
		local fespeed = 50
		local direction = Vector3.zero
		local humanoidRootPart

		local inputStates = {
			W = false,
			A = false,
			S = false,
			D = false,
			Space = false,
			LeftShift = false
		}

		player.CharacterAdded:Connect(function(char)
			humanoidRootPart = char:WaitForChild("HumanoidRootPart")
			humanoidRootPart.Anchored = flying
		end)

		if player.Character then
			humanoidRootPart = player.Character:WaitForChild("HumanoidRootPart")
			humanoidRootPart.Anchored = flying
		end

		local Toggle = Main:CreateToggle({
		Name = "Spectate Flight",
		CurrentValue = flying,
		Flag = "FlightToggle",
		Callback = function(value)
			flying = value
			if humanoidRootPart then
				humanoidRootPart.Anchored = flying
			end
		end,
		})

		UserInputService.InputBegan:Connect(function(input, gameProcessed)
			if gameProcessed then return end
			local key = input.KeyCode.Name
			if inputStates[key] ~= nil then
				inputStates[key] = true
			end
		end)

		UserInputService.InputEnded:Connect(function(input)
			local key = input.KeyCode.Name
			if inputStates[key] ~= nil then
				inputStates[key] = false
			end
		end)

		RunService.RenderStepped:Connect(function(deltaTime)
			if flying and humanoidRootPart then
				direction = Vector3.zero
				local cameraCFrame = camera.CFrame
				local lookVector = cameraCFrame.LookVector
				local rightVector = cameraCFrame.RightVector
				local upVector = cameraCFrame.UpVector

				if inputStates.W then
					direction += lookVector
				end
				if inputStates.S then
					direction -= lookVector
				end
				if inputStates.A then
					direction -= rightVector
				end
				if inputStates.D then
					direction += rightVector
				end
				if inputStates.Space then
					direction += upVector
				end
				if inputStates.LeftShift then
					direction -= upVector
				end

				if direction.Magnitude > 0 then
					direction = direction.Unit
					local moveDelta = direction * fespeed * deltaTime
					humanoidRootPart.CFrame = humanoidRootPart.CFrame + moveDelta
				end
			end
		end)

		local Slider = Main:CreateSlider({
		Name = "Flight Speed",
		Range = {0, 500},
		Increment = 10,
		Suffix = "Speed",
		CurrentValue = 50,
		Flag = "Slider1",
		Callback = function(Value)
			fespeed = Value
		end,
		})


		local RagdollToggle = Main:CreateToggle({
			Name = "Ragdoll",
			CurrentValue = false,
			Flag = "Toggle1",
			Callback = function(Value)
			pcall(function()
				local player = game.Players.LocalPlayer
				local character = player.Character or player.CharacterAdded:Wait()
				local humanoid = character:FindFirstChildOfClass("Humanoid")

				if Value then
					if humanoid then
						humanoid:ChangeState(Enum.HumanoidStateType.Physics)
						for _, part in pairs(character:GetChildren()) do
							if part:IsA("BasePart") then
								part.Anchored = false
								part.CanCollide = true
							end
						end
					end
				else
					if humanoid then
						humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
						for _, part in pairs(character:GetChildren()) do
							if part:IsA("BasePart") then
								part.Anchored = false
								part.CanCollide = true
							end
						end
					end
				end
				end)
			end,
		})

		Main:CreateButton({
			Name = "Get Radio",
			Callback = function()
			pcall(function()
				local player = game.Players.LocalPlayer

				for _, otherPlayer in pairs(game.Players:GetPlayers()) do
					if otherPlayer ~= player then
						local backpack = otherPlayer:FindFirstChild("Backpack")
						if backpack then
							local radio = backpack:FindFirstChild("Radio")
							if radio then
								local clonedRadio = radio:Clone()
								clonedRadio.Parent = player.Backpack
								return
							end
						end
					end
				end
				end)
			end,
		})

		Main:CreateButton({
			Name = "Respawn/Reset",
			Callback = function()
			pcall(function()
							local args = {
					{
						"Class - D",
						0,
						0,
						false,
						true
					},
					false,
					false
				}
				game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Spawn"):InvokeServer(unpack(args))
				end)
			end,
		})

		Main:CreateButton({
			Name = "Invisibility",
			Callback = function()
			pcall(function()
				local plr = game.Players.LocalPlayer
				local chr = plr.Character
				local hum = chr.HumanoidRootPart
				hum.Parent = nil
				hum.Parent = chr
				Rayfield:Notify({
					Title = "Became Invisible To Others",
					Content = "If u want to turn off reset",
					Duration = 6.5,
					Image = 4483362458,
				})
				Rayfield:Notify({
					Title = "Check",
					Content = "Make Sure to initialize invis in a hidden place if u want to kill people",
					Duration = 6.5,
					Image = 4483362458,
				})
				Rayfield:Notify({
					Title = "Success",
					Content = "If you get bugged use the button respawn in main section",
					Duration = 6.5,
					Image = 4483362458,
				})
				end)
			end,
		})

	local Combat = Window:CreateTab("Combat","sword")
	local Section = Combat:CreateSection("ESP")


	local lineThickness = 3.4

	Combat:CreateSlider({
		Name = "Line Thickness",
		Range = {0.5, 10},
		Increment = 0.1,
		Suffix = "Thickness",
		CurrentValue = lineThickness,
		Flag = "LineThicknessSlider",
		Callback = function(Value)
			lineThickness = Value
		end,
	})

    local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local Camera = workspace.CurrentCamera
	local LocalPlayer = Players.LocalPlayer

	local espBoxes = {}
	local wallGap = 2
	local connection = nil
	local playerAddedConnection = nil
	local playerRemovingConnection = nil

	local Boxes = Combat:CreateToggle({
		Name = "Boxes",
		CurrentValue = false,
		Flag = "Toggle1",
		Callback = function(Value)
		pcall(function()
			if Value == true then
				for _, player in pairs(Players:GetPlayers()) do
					if player ~= LocalPlayer and not espBoxes[player] then
						local box = {
							Top = Drawing.new("Line"),
							Bottom = Drawing.new("Line"),
							Left = Drawing.new("Line"),
							Right = Drawing.new("Line")
						}
						for _, line in pairs(box) do
							line.Thickness = lineThickness
							line.Transparency = 1
							line.ZIndex = 1
							line.Color = Color3.new(1, 1, 1)
							line.Visible = false
						end
						espBoxes[player] = box
					end
				end

				playerAddedConnection = Players.PlayerAdded:Connect(function(player)
					if player ~= LocalPlayer and not espBoxes[player] then
						local box = {
							Top = Drawing.new("Line"),
							Bottom = Drawing.new("Line"),
							Left = Drawing.new("Line"),
							Right = Drawing.new("Line")
						}
						for _, line in pairs(box) do
							line.Thickness = lineThickness
							line.Transparency = 1
							line.ZIndex = 1
							line.Color = Color3.new(1, 1, 1)
							line.Visible = false
						end
						espBoxes[player] = box
					end
				end)

				playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
					if espBoxes[player] then
						for _, line in pairs(espBoxes[player]) do
							line:Remove()
						end
						espBoxes[player] = nil
					end
				end)


				connection = RunService.RenderStepped:Connect(function(dt)

					for _, box in pairs(espBoxes) do
						for _, line in pairs(box) do
							if line.Thickness ~= lineThickness then
								line.Thickness = lineThickness
							end
						end
					end

					for player, box in pairs(espBoxes) do
						local character = player.Character
						local hrp = character and character:FindFirstChild("HumanoidRootPart")
						if character and hrp then
							local cf = hrp.CFrame
							local boxWidth = 2
							local boxHeight = 4
							local halfWidth = boxWidth / 2
							local halfHeight = boxHeight / 2

							local topLeft3D = cf * Vector3.new(-halfWidth, halfHeight, 0)
							local topRight3D = cf * Vector3.new(halfWidth, halfHeight, 0)
							local bottomLeft3D = cf * Vector3.new(-halfWidth, -halfHeight, 0)
							local bottomRight3D = cf * Vector3.new(halfWidth, -halfHeight, 0)

							local screenTL, onScreen1 = Camera:WorldToViewportPoint(topLeft3D)
							local screenTR, onScreen2 = Camera:WorldToViewportPoint(topRight3D)
							local screenBL, onScreen3 = Camera:WorldToViewportPoint(bottomLeft3D)
							local screenBR, onScreen4 = Camera:WorldToViewportPoint(bottomRight3D)

							if onScreen1 and onScreen2 and onScreen3 and onScreen4 then
								box.Top.From = Vector2.new(screenTL.X + wallGap, screenTL.Y)
								box.Top.To = Vector2.new(screenTR.X - wallGap, screenTR.Y)
								box.Bottom.From = Vector2.new(screenBL.X + wallGap, screenBL.Y)
								box.Bottom.To = Vector2.new(screenBR.X - wallGap, screenBR.Y)
								box.Left.From = Vector2.new(screenTL.X, screenTL.Y)
								box.Left.To = Vector2.new(screenBL.X, screenBL.Y)
								box.Right.From = Vector2.new(screenTR.X, screenTR.Y)
								box.Right.To = Vector2.new(screenBR.X, screenBR.Y)

								local color = player.Team and player.Team.TeamColor.Color or Color3.new(1, 1, 1)
								for _, line in pairs(box) do
									line.Color = color
									line.Visible = true
								end
							else
								for _, line in pairs(box) do
									line.Visible = false
								end
							end
						else
							for _, line in pairs(box) do
								line.Visible = false
							end
						end
					end
				end)
			else
				if connection then
					connection:Disconnect()
					connection = nil
				end

				if playerAddedConnection then
					playerAddedConnection:Disconnect()
					playerAddedConnection = nil
				end

				if playerRemovingConnection then
					playerRemovingConnection:Disconnect()
					playerRemovingConnection = nil
				end

				for player, box in pairs(espBoxes) do
					for _, line in pairs(box) do
						line.Visible = false
						line:Remove()
					end
					espBoxes[player] = nil
				end
				espBoxes = {}
			end
			end)
		end,
	})

	local Players = game:GetService("Players")
	local LocalPlayer = Players.LocalPlayer
	local nameLabels = {}
	local nameEspEnabled = false
	local playerAddedConn
	local charAddedConns = {}

	local NameEspToggle = Combat:CreateToggle({
		Name = "Names",
		CurrentValue = false,
		Flag = "ToggleNameESP",
		Callback = function(value)
		pcall(function()
			nameEspEnabled = value
			if nameEspEnabled then
				for _, player in pairs(Players:GetPlayers()) do
					if player.Character and not nameLabels[player.Character] then
						local head = player.Character:FindFirstChild("Head")
						if head then
							local billboard = Instance.new("BillboardGui")
							billboard.Name = randomString(32)
							billboard.Adornee = head
							billboard.Size = UDim2.new(0, 200, 0, 40)
							billboard.StudsOffset = Vector3.new(0, 2, 0)
							billboard.AlwaysOnTop = true
							billboard.Parent = game:GetService("CoreGui")

							local textLabel = Instance.new("TextLabel", billboard)
							textLabel.Size = UDim2.new(1, 0, 1, 0)
							textLabel.BackgroundTransparency = 1
							textLabel.TextColor3 = Color3.new(1, 1, 1)
							textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
							textLabel.TextStrokeTransparency = 0
							textLabel.Font = Enum.Font.SourceSansBold
							textLabel.TextSize = 18
							textLabel.TextScaled = false
							textLabel.TextWrapped = false
							textLabel.TextXAlignment = Enum.TextXAlignment.Center
							textLabel.TextYAlignment = Enum.TextYAlignment.Center

							nameLabels[player.Character] = billboard

							local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
							if humanoid then
							end
						end
					end
					charAddedConns[player] = player.CharacterAdded:Connect(function(character)
						if nameEspEnabled then
							local head = character:WaitForChild("Head", 5)
							if head and not nameLabels[character] then
								local billboard = Instance.new("BillboardGui")
								billboard.Name = randomString(32)
								billboard.Adornee = head
								billboard.Size = UDim2.new(0, 200, 0, 40)
								billboard.StudsOffset = Vector3.new(0, 2, 0)
								billboard.AlwaysOnTop = true
								billboard.Parent = game:GetService("CoreGui")

								local textLabel = Instance.new("TextLabel", billboard)
								textLabel.Size = UDim2.new(1, 0, 1, 0)
								textLabel.BackgroundTransparency = 1
								textLabel.TextColor3 = Color3.new(1, 1, 1)
								textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
								textLabel.TextStrokeTransparency = 0
								textLabel.Font = Enum.Font.SourceSansBold
								textLabel.TextSize = 18
								textLabel.TextScaled = false
								textLabel.TextWrapped = false
								textLabel.TextXAlignment = Enum.TextXAlignment.Center
								textLabel.TextYAlignment = Enum.TextYAlignment.Center

								nameLabels[character] = billboard

								local humanoid = character:FindFirstChildOfClass("Humanoid")
								if humanoid then
								end
							end
						end
					end)
				end

				playerAddedConn = Players.PlayerAdded:Connect(function(player)
					if nameEspEnabled then
						charAddedConns[player] = player.CharacterAdded:Connect(function(character)
							if nameEspEnabled then
								local head = character:WaitForChild("Head", 5)
								if head and not nameLabels[character] then
									local billboard = Instance.new("BillboardGui")
									billboard.Name = randomString(32)
									billboard.Adornee = head
									billboard.Size = UDim2.new(0, 200, 0, 40)
									billboard.StudsOffset = Vector3.new(0, 2, 0)
									billboard.AlwaysOnTop = true
									billboard.Parent = game:GetService("CoreGui")

									local textLabel = Instance.new("TextLabel", billboard)
									textLabel.Size = UDim2.new(1, 0, 1, 0)
									textLabel.BackgroundTransparency = 1
									textLabel.TextColor3 = Color3.new(1, 1, 1)
									textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
									textLabel.TextStrokeTransparency = 0
									textLabel.Font = Enum.Font.SourceSansBold
									textLabel.TextSize = 18
									textLabel.TextScaled = false
									textLabel.TextWrapped = false
									textLabel.TextXAlignment = Enum.TextXAlignment.Center
									textLabel.TextYAlignment = Enum.TextYAlignment.Center

									nameLabels[character] = billboard

									local humanoid = character:FindFirstChildOfClass("Humanoid")
									if humanoid then
									end
								end
							end
						end)
					end
				end)

				game:GetService("RunService").RenderStepped:Connect(function()
					if nameEspEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
						local localHRP = LocalPlayer.Character.HumanoidRootPart.Position
						for player, billboard in pairs(nameLabels) do
							if player and player.Parent and player:FindFirstChild("HumanoidRootPart") then
								local dist = (player.HumanoidRootPart.Position - localHRP).Magnitude
								local textLabel = billboard:FindFirstChildOfClass("TextLabel")
								if textLabel then
									local playerObj = Players:GetPlayerFromCharacter(player)
									if playerObj then
										textLabel.Text = playerObj.Name .. ", " .. math.floor(dist)
									end
								end
							end
						end
					end
				end)
			else
				for _, billboard in pairs(nameLabels) do
					billboard:Destroy()
				end
				nameLabels = {}

				if playerAddedConn then
					playerAddedConn:Disconnect()
					playerAddedConn = nil
				end
				for _, conn in pairs(charAddedConns) do
					conn:Disconnect()
				end
				charAddedConns = {}
			end
			end)
		end,
	})

	player.CharacterAdded:Connect(function(newCharacter)
	pcall(function()
		for oldCharacter, billboard in pairs(nameLabels) do
			local oldPlayer = Players:GetPlayerFromCharacter(oldCharacter)
			if oldPlayer == player and oldCharacter ~= newCharacter then
				if billboard then
					billboard:Destroy()
				end
				nameLabels[oldCharacter] = nil
			end
		end
		end)
	end)


	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer
	local Camera = workspace.CurrentCamera
	local tracers = {}
	local origin = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
	local tracerConnection = nil
	local playerRemovingConnection = nil
	local elapsed = 0

	local Toggle = Combat:CreateToggle({ 
		Name = "Tracers",
		CurrentValue = false,
		Flag = "Toggle1",
		Callback = function(enabled)
		pcall(function()
			if enabled then
				playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
					if tracers[player] then
						tracers[player]:Remove()
						tracers[player] = nil
					end
				end)

				tracerConnection = RunService.RenderStepped:Connect(function(dt)
					for _, line in pairs(tracers) do
						if line and line.Thickness ~= lineThickness then
							line.Thickness = lineThickness
						end
					end
					for _, player in pairs(Players:GetPlayers()) do
						if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
							local hrp = player.Character.HumanoidRootPart
							local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
							if onScreen then
								if not tracers[player] then
									local line = Drawing.new("Line")
									line.Visible = false
									line.Thickness = lineThickness
									line.Transparency = 1
									tracers[player] = line
								end
								local line = tracers[player]
								local teamColor = (player.Team and player.Team.TeamColor) and player.Team.TeamColor.Color or Color3.new(1,1,1)
								line.Color = teamColor
								line.From = origin
								line.To = Vector2.new(screenPos.X, screenPos.Y)
								line.Visible = true
							else
								if tracers[player] then
									tracers[player].Visible = false
								end
							end
						else
							if tracers[player] then
								tracers[player]:Remove()
								tracers[player] = nil
							end
						end
					end
				end)
			else
				if tracerConnection then
					tracerConnection:Disconnect()
					tracerConnection = nil
				end

				if playerRemovingConnection then
					playerRemovingConnection:Disconnect()
					playerRemovingConnection = nil
				end

				for player, line in pairs(tracers) do
					line.Visible = false
					line:Remove()
					tracers[player] = nil
				end
			end
			end)
		end,
	})

		local Section = Combat:CreateSection("Hitbox")

		local enableChecks = true

		local HeadHitboxSlider = Combat:CreateSlider({
			Name = "Head Hitbox Size",
			Range = {1, 4},
			Increment = 0.1,
			Suffix = "Size",
			CurrentValue = 1,
			Flag = "Toggle1",
			Callback = function(Value)
			pcall(function()
				_G.headsize = Value

				if not _G.headLoopRunning then
					_G.headLoopRunning = true
					spawn(function()
						while true do
							wait(1)
							local playerteamname = game.Players.LocalPlayer.Team and game.Players.LocalPlayer.Team.Name or "NoTeam"

							for _, player in ipairs(game.Players:GetPlayers()) do
								if player ~= game.Players.LocalPlayer then
									local character = player.Character
									if character then
										local head = character:FindFirstChild("Head")
										local otherteamname = player.Team and player.Team.Name or "NoTeam"
										local istarget = false

										if enableChecks then
											if playerteamname == "Class - D" then
												istarget = (otherteamname ~= playerteamname and otherteamname ~= "Chaos Insurgency")
											elseif playerteamname == "Chaos Insurgency" then
												istarget = (otherteamname ~= playerteamname and otherteamname ~= "Class - D")
											else
												istarget = (otherteamname == "Class - D" or otherteamname == "Chaos Insurgency")
											end
										else
											istarget = true
										end

										if istarget and head then
											head.Size = Vector3.new(_G.headsize, _G.headsize, _G.headsize)
											head.CanCollide = false
											head.Transparency = 1
										end
									end
								end
							end
						end
					end)
				end
				end)
			end,
		})

		local BodyHitboxToggle = Combat:CreateSlider({
			Name = "Body Hitbox Size",
			Range = {1, 4},
			Increment = 0.1,
			Suffix = "Size",
			CurrentValue = 1,
			Flag = "Toggle1",
			Callback = function(Value)
			pcall(function()
				_G.bodysize = Value

				if not _G.bodyLoopRunning then
					_G.bodyLoopRunning = true
					spawn(function()
						while true do
							wait(1)
							local playerteamname = game.Players.LocalPlayer.Team and game.Players.LocalPlayer.Team.Name or "NoTeam"

							for _, player in ipairs(game.Players:GetPlayers()) do
								if player ~= game.Players.LocalPlayer then
									local character = player.Character
									if character then
										local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
										local otherteamname = player.Team and player.Team.Name or "NoTeam"
										local istarget = false

										if enableChecks then
											if playerteamname == "Class - D" then
												istarget = (otherteamname ~= playerteamname and otherteamname ~= "Chaos Insurgency")
											elseif playerteamname == "Chaos Insurgency" then
												istarget = (otherteamname ~= playerteamname and otherteamname ~= "Class - D")
											else
												istarget = (otherteamname == "Class - D" or otherteamname == "Chaos Insurgency")
											end
										else
											istarget = true
										end

										if istarget and humanoidRootPart then
											humanoidRootPart.Size = Vector3.new(_G.bodysize, _G.bodysize, _G.bodysize)
											humanoidRootPart.CanCollide = false
											humanoidRootPart.Transparency = 1
										end
									end
								end
							end
						end
					end)
				end
				end)
			end,
		})

		game.Players.LocalPlayer:GetPropertyChangedSignal("Team"):Connect(function()
		pcall(function()
			if _G.headsize or _G.bodysize then
				for _, player in ipairs(game.Players:GetPlayers()) do
					if player.Character then
						local character = player.Character
						local head = character:FindFirstChild("Head")
						local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
							head.Size = Vector3.new(1, 1, 1)
							head.CanCollide = false
							head.Transparency = 0
							humanoidRootPart.Size = Vector3.new(1, 1, 1)
							humanoidRootPart.CanCollide = false
							humanoidRootPart.Transparency = 1
					end
				end
			end
			end)
		end)

		local Section = Combat:CreateSection("Silent Aim")
		local Players = game:GetService("Players")
		local UserInputService = game:GetService("UserInputService")
		local ReplicatedStorage = game:GetService("ReplicatedStorage") 
		local localPlayer = Players.LocalPlayer
		local camera = workspace.CurrentCamera
		local raycastEnabled = false
		local holdingLclick = false
		local aimFov = 40
		local silentenabled = false
		local mouse = localPlayer:GetMouse()
		local mouseWeight = 0.5
		local Ratez = 0.06

		UserInputService.InputBegan:Connect(function(input)
		 pcall(function()
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				if not holdingLclick then
					holdingLclick = true
					while holdingLclick and silentenabled do
						local facingplayer = nil
						local bestScore = math.huge
						local cameradirc = camera.CFrame.LookVector

						for _, player in pairs(Players:GetPlayers()) do
							if player ~= localPlayer and player.Character and player.Character:FindFirstChild("Head") then
								local playerteamname = localPlayer.Team and localPlayer.Team.Name or "NoTeam"
								local otherteamname = player.Team and player.Team.Name or "NoTeam"
								local character = localPlayer.Character
								local otherCharacter = player.Character

								if character and otherCharacter and otherCharacter:FindFirstChild("HumanoidRootPart") then
									local head = otherCharacter:FindFirstChild("Head")
									local istarget = false
									if (head and head.BrickColor == BrickColor.new("Olivine")) 
									or (workspace:FindFirstChild(player.Name) and workspace:FindFirstChild(player.Name):FindFirstChild("001MorphBits")) then
										isvalidtarget = true
										istarget = true
									elseif enableChecks then
										if playerteamname == "Class - D" or playerteamname == "Chaos Insurgency" then
											if otherteamname ~= "Class - D" and otherteamname ~= "Chaos Insurgency" then
												local targetposition = otherCharacter.HumanoidRootPart.Position
												local inregion = false
												local regions = {
														SCIENTIFIC_DEPARTMENT_1 = { min = Vector3.new(16.3, 2.0, -168.8),   max = Vector3.new(47.1, 12.7, -104.8) }, -- fixed
														SCIENTIFIC_DEPARTMENT_2 = { min = Vector3.new(-13.1, -0.3, -155.9), max = Vector3.new(10.9, 10.6, -124.8) }, -- fixed
														SECURITY_DEPARTMENT     = { min = Vector3.new(-31.8, -0.3, -248.5), max = Vector3.new(13.1, 17.8, -202.7) }, -- fixed
														MTF_1                   = { min = Vector3.new(-149.3, -0.3, -858.9), max = Vector3.new(-4.8, 13.6, -805.1) }, -- fixed
														MTF_2                   = { min = Vector3.new(-115.6, -1.1, -870.8), max = Vector3.new(-37.4, 23.9, -799.1) }, -- fixed
														RRT_1                   = { min = Vector3.new(-33.7, 42.3, 54.8),    max = Vector3.new(20.1, 56.9, 90.4) },   -- fixed
														RRT_2                   = { min = Vector3.new(3.2, 42.3, 89.4),     max = Vector3.new(19.1, 56.0, 105.3) },  -- fixed
														RRT_3                   = { min = Vector3.new(-10.0, -0.3, 92.3),    max = Vector3.new(20.5, 13.3, 111.6) },  -- fixed
														INTERNAL_SECURITY_DEPARTMENT       = { min = Vector3.new(-177.2, -0.3, 100.2), max = Vector3.new(-136.9, 16.5, 133.8) }, -- fixed
														INTERNAL_SECURITY_DEPARTMENT_roombig = { min = Vector3.new(-196.7, -0.3, 135.6), max = Vector3.new(-121.6, 16.5, 179.0) }, -- fixed
														INTELLIGENCE_AGENCY     = { min = Vector3.new(-236.4, -0.3, 135.9), max = Vector3.new(-202.0, 16.5, 178.2) }, -- fixed
														IA_ROOMBIG1             = { min = Vector3.new(-172.7, -0.3, 183.1), max = Vector3.new(-129.5, 12.9, 217.2) }, -- fixed
														IA_ROOMBIG2             = { min = Vector3.new(-172.9, -0.3, 182.8), max = Vector3.new(-89.4, 13.1, 201.0) },  -- fixed
														IA_ROOMBIG3             = { min = Vector3.new(-107.7, -0.3, 147.0), max = Vector3.new(-89.2, 13.1, 201.0) },  -- fixed
														ADMINISTRATIVE          = { min = Vector3.new(89.8, -0.3, 294.0),   max = Vector3.new(143.4, 12.7, 343.8) },  -- fixed
														O5_SPAWN                = { min = Vector3.new(24.3, -0.3, 122.7),   max = Vector3.new(72.0, 13.1, 220.2) }  -- fixed

												}
												for _, region in pairs(regions) do
													if (targetposition.X >= region.min.X and targetposition.X <= region.max.X) and
													(targetposition.Y >= region.min.Y and targetposition.Y <= region.max.Y) and
													(targetposition.Z >= region.min.Z and targetposition.Z <= region.max.Z) then
														inregion = true
														break
													end
												end
												istarget = not inregion
											end
										else
											if otherteamname == "Class - D" then
												local targetposition = otherCharacter.HumanoidRootPart.Position
												local inarea = targetposition.X >= -0 and targetposition.X <= 0 and
															targetposition.Y >= 0 and targetposition.Y <= 0 and
															targetposition.Z >= 0 and targetposition.Z <= 0
												local hasgun = false
												for _, tool in ipairs(otherCharacter:GetChildren()) do
													if tool:IsA("Tool") and tool:FindFirstChild("Laser") then
														hasgun = true
														break
													end
												end
												istarget = not inarea or hasgun
											elseif otherteamname == "Chaos Insurgency" then
												istarget = true
											end
										end
									else
										istarget = true
									end

									if istarget then
										local humanoid = player.Character:FindFirstChild("Humanoid")
										if humanoid and humanoid.Health > 0 then
											local head = player.Character.Head
											local directiontoplayer = (head.Position - localPlayer.Character.Head.Position).Unit
											local distance = (head.Position - localPlayer.Character.Head.Position).Magnitude
											local angle = math.acos(cameradirc:Dot(directiontoplayer))
											local fovRadians = math.rad(aimFov / 2)

											if angle <= fovRadians then
												local screenPoint = camera:WorldToScreenPoint(head.Position)
												local mouseDistance = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
												local combinedScore = (distance * (1 - mouseWeight)) + (mouseDistance * mouseWeight)
												
												if combinedScore < bestScore then
													bestScore = combinedScore
													facingplayer = player
												end
											end
										end
									end
								end
							end
						end

						if facingplayer and facingplayer.Character and facingplayer.Character:FindFirstChild("Head") then
							local headPosition = facingplayer.Character.Head.Position
							local mhp = localPlayer.Character.Head.Position
							local distance = (headPosition - mhp).Magnitude

							if distance <= 23232 then
								local canFire = true
								if not raycastEnabled then
									local targetChar = targetPlayer and targetPlayer.Character
									local ignoreInstances = {
										localPlayer.Character,
										targetChar,
										workspace:FindFirstChild("MorphAssets")
									}
									local obscuringParts = workspace.CurrentCamera:GetPartsObscuringTarget(
										{mhp, headPosition},
										ignoreInstances
									)
									if #obscuringParts > 0 then
										local blocked = false
										for _, part in ipairs(obscuringParts) do
											blocked = true
											break
										end

										if blocked then
											canFire = false
										end
									end
								end

								local Players = game:GetService("Players")
								local localPlayer = Players.LocalPlayer

								if canFire then   
										local mousePos = game:GetService("UserInputService"):GetMouseLocation()
										local viewportRay = workspace.CurrentCamera:ViewportPointToRay(mousePos.X, mousePos.Y)
										local raycastParams = RaycastParams.new()
										raycastParams.FilterDescendantsInstances = {game:GetService("Players").LocalPlayer.Character}
										raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
										local raycastResult = workspace:Raycast(
										viewportRay.Origin,
										viewportRay.Direction * 1000,
										raycastParams)
						
									local args = {
										{
											{
												raycastResult.Position.X,
												raycastResult.Position.Y,
												raycastResult.Position.Z
											},
											true
										},
										game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(1,1,1),
										game.Players[facingplayer.Name].Character.Head
									}
									game:GetService("ReplicatedStorage").Remotes.RemoteEvent:FireServer(unpack(args))
								end
							end
						end
						task.wait(Ratez)
					end
				end
			end
			end)
		end)

			UserInputService.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				holdingLclick = false
			end
		end)

		local SilentToggle = Combat:CreateToggle({
			Name = "Enable Silent Aim",
			CurrentValue = false,
			Flag = "SilentAimToggle",
			Callback = function(Value)
				silentenabled = Value
			end,
		})

		local SilentRate = Combat:CreateToggle({
			Name = "2x Silent Aim Fire Rate (Risky)",
			CurrentValue = false,
			Flag = "Ratez",
			Callback = function(Value)
				if Value then
					Ratez = 0.03
					else
					Ratez = 0.06
				end
			end,
		})

		local RCToggle = Combat:CreateToggle({
			Name = "WallBang (Silent Aim only) (Shoots Thru Walls)",
			CurrentValue = false,
			Flag = "ToggleRaycast",
			Callback = function(Value)
				raycastEnabled = Value
			end,
		})

		local Slider = Combat:CreateSlider({
		Name = "FOV",
		Range = {0, 80},
		Increment = 1,
		Suffix = " ",
		CurrentValue = 40,
		Flag = "Slider1", 
		Callback = function(Value)
		aimFov = Value
		end,
		})

		local drawingCircle

		local Toggle = Combat:CreateToggle({
			Name = "Show FOV",
			CurrentValue = false,
			Flag = "Toggle1",
			Callback = function(Value)
			 pcall(function()
				if Value then
					drawingCircle = Drawing.new("Circle")
					drawingCircle.Thickness = 2
					drawingCircle.NumSides = 64
					drawingCircle.Color = Color3.new(1, 1, 1)
					drawingCircle.Transparency = 1
					drawingCircle.Filled = false
					drawingCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
					drawingCircle.Visible = true
					
					game:GetService("RunService").RenderStepped:Connect(function()
						if drawingCircle then
							drawingCircle.Radius = aimFov * 5
						end
					end)
				else
					if drawingCircle then
						drawingCircle:Remove()
						drawingCircle = nil
					end
				end
				end)
			end,
		})



		local Section = Combat:CreateSection("Aimbot")
		local playerss = game:GetService("Players")
		local frameservc = game:GetService("RunService")
		local inputservc = game:GetService("UserInputService")
		local guiservc = game:GetService("GuiService")
		local localplayerinstc = playerss.LocalPlayer
		local currentcameradistance = workspace.CurrentCamera
		local isrclickheld = false
		local isaimbotenabled = false
		local israycaston = false
		local tfov = 40
		local mouse = localplayerinstc:GetMouse()
		local mouseWeight = 0.5
		local selectedpart = "Head"

		local Dropdown = Combat:CreateDropdown({
		Name = "Aim Part",
		Options = {"Head", "Torso"},
		CurrentOption = {"Head"},
		MultipleOptions = false,
		Flag = "Dropdown1",
		Callback = function(Options)
			selectedpart = Options[1]
		end,
		})

		inputservc.InputBegan:Connect(function(inputEvent)
		pcall(function()
			if inputEvent.UserInputType == Enum.UserInputType.MouseButton2 then
				isrclickheld = true
				if isaimbotenabled then
					local character = localplayerinstc.Character
					if character then
						local hasTool = false
						for _, child in ipairs(character:GetChildren()) do
							if child:IsA("Tool") then
								hasTool = true
								break
							end
						end
						if hasTool then
							local closestplayer = nil
							local bestscore = math.huge
							local cameradirc = currentcameradistance.CFrame.LookVector

							for _, player in pairs(playerss:GetPlayers()) do
								if player ~= localplayerinstc and player.Character and player.Character:FindFirstChild("Head") then
									local localTeamName = localplayerinstc.Team and localplayerinstc.Team.Name or "NoTeam"
									local targetteamname = player.Team and player.Team.Name or "NoTeam"
									local localCharacter = localplayerinstc.Character
									local targetCharacter = player.Character

									if localCharacter and targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then
										local targetHead = targetCharacter:FindFirstChild("Head")
										local isvalidtarget = false

										if (targetHead and targetHead.BrickColor == BrickColor.new("Olivine")) 
										or (workspace:FindFirstChild(player.Name) and workspace:FindFirstChild(player.Name):FindFirstChild("001MorphBits")) then
											isvalidtarget = true
										elseif enableChecks then
											if localTeamName == "Class - D" or localTeamName == "Chaos Insurgency" then
												if targetteamname ~= "Class - D" and targetteamname ~= "Chaos Insurgency" then
													local targetposition = targetCharacter.HumanoidRootPart.Position
													local inregion = false
													local regions = {
																SCIENTIFIC_DEPARTMENT_1 = { min = Vector3.new(16.3, 2.0, -168.8),   max = Vector3.new(47.1, 12.7, -104.8) }, -- fixed
																SCIENTIFIC_DEPARTMENT_2 = { min = Vector3.new(-13.1, -0.3, -155.9), max = Vector3.new(10.9, 10.6, -124.8) }, -- fixed
																SECURITY_DEPARTMENT     = { min = Vector3.new(-31.8, -0.3, -248.5), max = Vector3.new(13.1, 17.8, -202.7) }, -- fixed
																MTF_1                   = { min = Vector3.new(-149.3, -0.3, -858.9), max = Vector3.new(-4.8, 13.6, -805.1) }, -- fixed
																MTF_2                   = { min = Vector3.new(-115.6, -1.1, -870.8), max = Vector3.new(-37.4, 23.9, -799.1) }, -- fixed
																RRT_1                   = { min = Vector3.new(-33.7, 42.3, 54.8),    max = Vector3.new(20.1, 56.9, 90.4) },   -- fixed
																RRT_2                   = { min = Vector3.new(3.2, 42.3, 89.4),     max = Vector3.new(19.1, 56.0, 105.3) },  -- fixed
																RRT_3                   = { min = Vector3.new(-10.0, -0.3, 92.3),    max = Vector3.new(20.5, 13.3, 111.6) },  -- fixed
																INTERNAL_SECURITY_DEPARTMENT       = { min = Vector3.new(-177.2, -0.3, 100.2), max = Vector3.new(-136.9, 16.5, 133.8) }, -- fixed
																INTERNAL_SECURITY_DEPARTMENT_roombig = { min = Vector3.new(-196.7, -0.3, 135.6), max = Vector3.new(-121.6, 16.5, 179.0) }, -- fixed
																INTELLIGENCE_AGENCY     = { min = Vector3.new(-236.4, -0.3, 135.9), max = Vector3.new(-202.0, 16.5, 178.2) }, -- fixed
																IA_ROOMBIG1             = { min = Vector3.new(-172.7, -0.3, 183.1), max = Vector3.new(-129.5, 12.9, 217.2) }, -- fixed
																IA_ROOMBIG2             = { min = Vector3.new(-172.9, -0.3, 182.8), max = Vector3.new(-89.4, 13.1, 201.0) },  -- fixed
																IA_ROOMBIG3             = { min = Vector3.new(-107.7, -0.3, 147.0), max = Vector3.new(-89.2, 13.1, 201.0) },  -- fixed
																ADMINISTRATIVE          = { min = Vector3.new(89.8, -0.3, 294.0),   max = Vector3.new(143.4, 12.7, 343.8) },  -- fixed
																O5_SPAWN                = { min = Vector3.new(24.3, -0.3, 122.7),   max = Vector3.new(72.0, 13.1, 220.2) }  -- fixed

													}
													for _, region in pairs(regions) do
														if (targetposition.X >= region.min.X and targetposition.X <= region.max.X) and
														(targetposition.Y >= region.min.Y and targetposition.Y <= region.max.Y) and
														(targetposition.Z >= region.min.Z and targetposition.Z <= region.max.Z) then
															inregion = true
															break
														end
													end
													isvalidtarget = not inregion
												end
											else
												if targetteamname == "Class - D" then
													local targetposition = targetCharacter.HumanoidRootPart.Position
													local inarea = targetposition.X >= 0 and targetposition.X <= 0 and
																targetposition.Y >= 0 and targetposition.Y <= 0 and
																targetposition.Z >= 0 and targetposition.Z <= 0
													local hasweapon = false
													for _, item in ipairs(targetCharacter:GetChildren()) do
														if item:IsA("Tool") and item:FindFirstChild("Laser") then
															hasweapon = true
															break
														end
													end
													isvalidtarget = not inarea or hasweapon
												elseif targetteamname == "Chaos Insurgency" then
													isvalidtarget = true
												end
											end
										else
											isvalidtarget = true
										end
										if isvalidtarget then
											local humanoid = player.Character:FindFirstChild("Humanoid")
											if humanoid and humanoid.Health > 0 then
												local playerhead = player.Character.Head
												local directiontoplayer = (playerhead.Position - localplayerinstc.Character.Head.Position).Unit
												local distancetoplayer = (playerhead.Position - localplayerinstc.Character.Head.Position).Magnitude
												local angleBetween = math.acos(cameradirc:Dot(directiontoplayer))
												local halfFOVRadians = math.rad(tfov / 2)

												if angleBetween <= halfFOVRadians then
													local screenPoint = currentcameradistance:WorldToScreenPoint(playerhead.Position)
													local mouseDistance = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
													local combinedScore = (distancetoplayer * (1 - mouseWeight)) + (mouseDistance * mouseWeight)
													
													if combinedScore < bestscore then
														bestscore = combinedScore
														closestplayer = player
													end
												end
											end
										end
									end
								end
							end

							if closestplayer and closestplayer.Character then
								local canTarget = true
								if israycaston then
									local targetChar = closestplayer.Character
									local localChar = localplayerinstc.Character
									local targetHead = targetChar and targetChar:FindFirstChild("Head")
									local localHead = localChar and localChar:FindFirstChild("Head")
										if targetHead and localHead then
											local partsObscuring = workspace.CurrentCamera:GetPartsObscuringTarget(
												{localHead.Position, targetHead.Position},
												{localChar, closestplayer.Character, workspace.MorphAssets}
											)

											if #partsObscuring > 0 then
												local isObstructed = false

												for _, part in ipairs(partsObscuring) do
													isObstructed = true
													break
												end

												if isObstructed then
													canTarget = false
												end
											end
										else
										canTarget = false
									end
								end
								if canTarget then
									local targetPart
									if selectedpart == "Head" then
										targetPart = closestplayer.Character:FindFirstChild("Head")
									elseif selectedpart == "Torso" then
										targetPart = closestplayer.Character:FindFirstChild("HumanoidRootPart")
									end

									if targetPart then
										currentcameradistance.CFrame = CFrame.new(currentcameradistance.CFrame.Position, targetPart.Position)
									end
								end
							end
						end
					end
				end
			end
			end)
		end)

		inputservc.InputEnded:Connect(function(inputEvent)
			if inputEvent.UserInputType == Enum.UserInputType.MouseButton2 then
				isrclickheld = false
			end
		end)

		frameservc.RenderStepped:Connect(function()
		pcall(function()
		if isrclickheld and isaimbotenabled then
				local character = localplayerinstc.Character
				if character then
					local hasTool = false
					for _, child in ipairs(character:GetChildren()) do
						if child:IsA("Tool") then
							hasTool = true
							break
						end
					end
					if hasTool then
						local closestplayer = nil
						local bestscore = math.huge
						local cameradirc = currentcameradistance.CFrame.LookVector

						for _, player in pairs(playerss:GetPlayers()) do
							if player ~= localplayerinstc and player.Character and player.Character:FindFirstChild("Head") then
								local localTeamName = localplayerinstc.Team and localplayerinstc.Team.Name or "NoTeam"
								local targetteamname = player.Team and player.Team.Name or "NoTeam"
								local localCharacter = localplayerinstc.Character
								local targetCharacter = player.Character

								if localCharacter and targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart") then
									local targetHead = targetCharacter:FindFirstChild("Head")
									local isvalidtarget = false

									if (targetHead and targetHead.BrickColor == BrickColor.new("Olivine")) 
									or (workspace:FindFirstChild(player.Name) and workspace:FindFirstChild(player.Name):FindFirstChild("001MorphBits")) then
										isvalidtarget = true
									elseif enableChecks then
										if localTeamName == "Class - D" or localTeamName == "Chaos Insurgency" then
											if targetteamname ~= "Class - D" and targetteamname ~= "Chaos Insurgency" then
												local targetposition = targetCharacter.HumanoidRootPart.Position
												local inregion = false
												local regions = {
													SCIENTIFIC_DEPARTMENT_1 = { min = Vector3.new(16.3, 2.0, -168.8),   max = Vector3.new(47.1, 12.7, -104.8) }, -- fixed
													SCIENTIFIC_DEPARTMENT_2 = { min = Vector3.new(-13.1, -0.3, -155.9), max = Vector3.new(10.9, 10.6, -124.8) }, -- fixed
													SECURITY_DEPARTMENT     = { min = Vector3.new(-31.8, -0.3, -248.5), max = Vector3.new(13.1, 17.8, -202.7) }, -- fixed
													MTF_1                   = { min = Vector3.new(-149.3, -0.3, -858.9), max = Vector3.new(-4.8, 13.6, -805.1) }, -- fixed
													MTF_2                   = { min = Vector3.new(-115.6, -1.1, -870.8), max = Vector3.new(-37.4, 23.9, -799.1) }, -- fixed
													RRT_1                   = { min = Vector3.new(-33.7, 42.3, 54.8),    max = Vector3.new(20.1, 56.9, 90.4) },   -- fixed
													RRT_2                   = { min = Vector3.new(3.2, 42.3, 89.4),     max = Vector3.new(19.1, 56.0, 105.3) },  -- fixed
													RRT_3                   = { min = Vector3.new(-10.0, -0.3, 92.3),    max = Vector3.new(20.5, 13.3, 111.6) },  -- fixed
													INTERNAL_SECURITY_DEPARTMENT       = { min = Vector3.new(-177.2, -0.3, 100.2), max = Vector3.new(-136.9, 16.5, 133.8) }, -- fixed
													INTERNAL_SECURITY_DEPARTMENT_roombig = { min = Vector3.new(-196.7, -0.3, 135.6), max = Vector3.new(-121.6, 16.5, 179.0) }, -- fixed
													INTELLIGENCE_AGENCY     = { min = Vector3.new(-236.4, -0.3, 135.9), max = Vector3.new(-202.0, 16.5, 178.2) }, -- fixed
													IA_ROOMBIG1             = { min = Vector3.new(-172.7, -0.3, 183.1), max = Vector3.new(-129.5, 12.9, 217.2) }, -- fixed
													IA_ROOMBIG2             = { min = Vector3.new(-172.9, -0.3, 182.8), max = Vector3.new(-89.4, 13.1, 201.0) },  -- fixed
													IA_ROOMBIG3             = { min = Vector3.new(-107.7, -0.3, 147.0), max = Vector3.new(-89.2, 13.1, 201.0) },  -- fixed
													ADMINISTRATIVE          = { min = Vector3.new(89.8, -0.3, 294.0),   max = Vector3.new(143.4, 12.7, 343.8) },  -- fixed
													O5_SPAWN                = { min = Vector3.new(24.3, -0.3, 122.7),   max = Vector3.new(72.0, 13.1, 220.2) }  -- fixed

												}
												for _, region in pairs(regions) do
													if (targetposition.X >= region.min.X and targetposition.X <= region.max.X) and
													(targetposition.Y >= region.min.Y and targetposition.Y <= region.max.Y) and
													(targetposition.Z >= region.min.Z and targetposition.Z <= region.max.Z) then
														inregion = true
														break
													end
												end
												isvalidtarget = not inregion
											end
										else
											if targetteamname == "Class - D" then
												local targetposition = targetCharacter.HumanoidRootPart.Position
												local inarea = targetposition.X >= -0 and targetposition.X <= 0 and
															targetposition.Y >= 0 and targetposition.Y <= 0 and
															targetposition.Z >= 0 and targetposition.Z <= 0
												local hasweapon = false
												for _, item in ipairs(targetCharacter:GetChildren()) do
													if item:IsA("Tool") and item:FindFirstChild("Laser") then
														hasweapon = true
														break
													end
												end
												isvalidtarget = not inarea or hasweapon
											elseif targetteamname == "Chaos Insurgency" then
												isvalidtarget = true
											end
										end
									else
										isvalidtarget = true
									end

									if isvalidtarget then
										local humanoid = player.Character:FindFirstChild("Humanoid")
										if humanoid and humanoid.Health > 0 then
											local playerhead = player.Character.Head
											local directiontoplayer = (playerhead.Position - localplayerinstc.Character.Head.Position).Unit
											local distancetoplayer = (playerhead.Position - localplayerinstc.Character.Head.Position).Magnitude
											local angleBetween = math.acos(cameradirc:Dot(directiontoplayer))
											local halfFOVRadians = math.rad(tfov / 2)
											if angleBetween <= halfFOVRadians then
												local screenPoint = currentcameradistance:WorldToScreenPoint(playerhead.Position)
												local mouseDistance = (Vector2.new(screenPoint.X, screenPoint.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude
												local combinedScore = (distancetoplayer * (1 - mouseWeight)) + (mouseDistance * mouseWeight)
												
												if combinedScore < bestscore then
													bestscore = combinedScore
													closestplayer = player
												end
											end
										end
									end
								end
							end
						end

						if closestplayer and closestplayer.Character then
							local canTarget = true
								if israycaston then
									local targetChar = closestplayer.Character
									local localChar = localplayerinstc.Character
									local targetHead = targetChar and targetChar:FindFirstChild("Head")
									local localHead = localChar and localChar:FindFirstChild("Head")
										if targetHead and localHead then
											local partsObscuring = workspace.CurrentCamera:GetPartsObscuringTarget(
												{localHead.Position, targetHead.Position},
												{localChar, closestplayer.Character, workspace.MorphAssets}
											)

											if #partsObscuring > 0 then
												local isObstructed = false

												for _, part in ipairs(partsObscuring) do
													isObstructed = true
													break
												end

												if isObstructed then
													canTarget = false
												end
											end
										else
										canTarget = false
									end
								end

							if canTarget then
								local targetPart
								if selectedpart == "Head" then
									targetPart = closestplayer.Character:FindFirstChild("Head")
								elseif selectedpart == "Torso" then
									targetPart = closestplayer.Character:FindFirstChild("HumanoidRootPart")
								end

								if targetPart then
									currentcameradistance.CFrame = CFrame.new(currentcameradistance.CFrame.Position, targetPart.Position)
								end
							end
						end
					end
				end
			end
			end)
		end)

		local AimbotToggle = Combat:CreateToggle({
			Name = "Aimbot (Risky)",
			CurrentValue = false,
			Flag = "ToggleCameraLock",
			Callback = function(Value)
				isaimbotenabled = Value
			end,
		})

		local RaycastToggle = Combat:CreateToggle({
			Name = "Wallcheck",
			CurrentValue = false,
			Flag = "ToggleRaycast",
			Callback = function(Value)
				israycaston = Value
			end,
		})

		local FOVSlider = Combat:CreateSlider({
			Name = "FOV",
			Range = {0, 80},
			Increment = 1,
			Suffix = " ",
			CurrentValue = 40,
			Flag = "Slider1",
			Callback = function(Value)
				tfov = Value
			end,
		})

		local FOVCircle1

		local FOVToggle = Combat:CreateToggle({
			Name = "Show FOV",
			CurrentValue = false,
			Flag = "ToggleFOVCircle",
			Callback = function(Value)
				if Value then
					FOVCircle1 = Drawing.new("Circle")
					FOVCircle1.Thickness = 2
					FOVCircle1.NumSides = 64
					FOVCircle1.Color = Color3.new(1, 1, 1)
					FOVCircle1.Transparency = 1
					FOVCircle1.Filled = false
					FOVCircle1.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
					FOVCircle1.Visible = true

					game:GetService("RunService").RenderStepped:Connect(function()
						if FOVCircle1 then
							FOVCircle1.Radius = tfov * 5
						end
					end)
				else
					if FOVCircle1 then
						FOVCircle1:Remove()
						FOVCircle1 = nil
					end
				end
			end,
		})

		local World = Window:CreateTab("World", "earth") 
		local Section = World:CreateSection(" ")

		local Button = World:CreateButton({
			Name = "Destroy Doors",
			Callback = function()
				for _, z in ipairs(workspace:GetDescendants()) do
					if string.lower(z.Name):find("door") then
						z:Destroy()
					end
				end
			end,
		})

		local Button = World:CreateButton({
			Name = "Destroy Everything",
			Callback = function()
                for _, obj in pairs(workspace:GetDescendants()) do
                    if obj:IsA("BasePart") and obj.Position.Y > 1.1 then
                        local model = obj:FindFirstAncestorOfClass("Model")
                        if not (model and model:FindFirstChildOfClass("Humanoid")) then
                            obj:Destroy()
                        end
                    end
                end
                FullBrightToggle:Set(true)
			end,
		})

		local FakeChat = Window:CreateTab("Fake Chat", "message-circle-more")
		local Section = FakeChat:CreateSection(" ")
		local Paragraph = FakeChat:CreateParagraph({Title = "Fake Chat", Content = "Fake chat makes it look like a player sent a message (can be swearing) to fake report the player if you dont like him or for fun, only you can see the message"})
		local fakechatenabled = false
		local notiffenabled = true
		local targetplayer
		local message
		local Chat = game:GetService("Chat")

		local Toggle = FakeChat:CreateToggle({
		Name = "Enabled",
		CurrentValue = false,
		Flag = "Toggle1",
		Callback = function(Value)
			fakechatenabled = Value
		end,
		})

		local Toggle = FakeChat:CreateToggle({
		Name = "Send Notifications",
		CurrentValue = true,
		Flag = "Toggle1",
		Callback = function(Value)
			notiffenabled = Value
		end,
		})


		local Input = FakeChat:CreateInput({
		Name = "Target Player",
		CurrentValue = "",
		PlaceholderText = "name",
		RemoveTextAfterFocusLost = false,
		Flag = "Input1",
		Callback = function(Text)
			targetplayer = Text
		end,
		})

		local Input = FakeChat:CreateInput({
		Name = "Message",
		CurrentValue = "",
		PlaceholderText = "message",
		RemoveTextAfterFocusLost = false,
		Flag = "Input1",
		Callback = function(Text)
			message = Text
		end,
		})

		game:GetService("UserInputService").InputBegan:Connect(function(input)
		pcall(function()
			if input.KeyCode == Enum.KeyCode.Z and fakechatenabled then
				local target = nil
				local inputLower = (targetplayer or ""):lower()

				for _, plr in ipairs(game:GetService("Players"):GetPlayers()) do
					if plr.Name:lower():sub(1, #inputLower) == inputLower or plr.DisplayName:lower():sub(1, #inputLower) == inputLower then
						target = plr
						break
					end
				end

				if not target and notiffenabled then
					Rayfield:Notify({
						Title = "Can't find the player",
						Content = "",
						Duration = 3,
						Image = 4483362458,
					})
				end

				if target and target.Character then
					Chat:Chat(target.Character, message)
				end
			end
			end)
		end)

		local Label = FakeChat:CreateLabel("Press Z To Send The Message", "message-circle-more", Color3.fromRGB(0, 0, 0), false)
		local Misc = Window:CreateTab("Misc", 4483362458) 
		local MiscSection = Misc:CreateSection("Misc")

		local Toggle = Misc:CreateToggle({
			Name = "Disable Team Checks",
			CurrentValue = false,
			Flag = "Toggle1",
			Callback = function(Value)
				enableChecks = not Value
			end,
		})

		local Button = Misc:CreateButton({
			Name = "Server Hop",
			Callback = function()
				pcall(function()
					local Players = game:GetService("Players")
					local HttpService = game:GetService("HttpService")
					local TeleportService = game:GetService("TeleportService")
					local placeId = game.PlaceId
					local jobId = game.JobId

					local function findServer(minPlayers, maxPlayers)
						local cursor = nil
						repeat
							local url = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Desc&limit=100"
							if cursor then
								url = url .. "&cursor=" .. cursor
							end

							local ok, response = pcall(function()
								return HttpService:JSONDecode(game:HttpGet(url))
							end)

							if ok and response and response.data then
								for _, server in ipairs(response.data) do
									if server.id ~= jobId and server.playing >= minPlayers and server.playing <= maxPlayers and server.playing < server.maxPlayers then
										return server.id
									end
								end
								cursor = response.nextPageCursor
							else
								break
							end
						until not cursor

						return nil
					end

					local bestServerId = findServer(40, 48) or findServer(20, 40)

					if bestServerId then
						queue_on_teleport([[
							loadstring(game:HttpGet('https://raw.githubusercontent.com/axleoislost/Accent/main/Scp-Roleplay'))()
						]])
						TeleportService:TeleportToPlaceInstance(placeId, bestServerId, Players.LocalPlayer)
					else
						Rayfield:Notify({
							Title = "No Servers Found",
							Content = "Couldn't find another available server.",
							Duration = 6.5,
							Image = 4370317928,
						})
					end
				end)
			end,
		})

		local Button = Misc:CreateButton({
			Name = "Rejoin Current Server",
			Callback = function()
				queue_on_teleport([[
					loadstring(game:HttpGet('https://raw.githubusercontent.com/axleoislost/Accent/main/Scp-Roleplay'))()
				]])
				game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, game:GetService("Players").LocalPlayer)
			end,
		})

		local Slider = Misc:CreateSlider({
			Name = "FPS Limit",
			Range = {5, 500},
			Increment = 5,
			Suffix = "FPS",
			CurrentValue = 60,
			Flag = "Slider1", 
			Callback = function(Value)
				setfpscap(Value)
			end,
		})

		local TurnOff = Misc:CreateToggle({
			Name = "Turn Off Everything When a Moderator Joins",
			CurrentValue = false,
			Flag = "Toggle1",
			Callback = function(Value)
			  pcall(function()
				for _, plr in next, game.Players:GetPlayers() do
					if plr:GetRankInGroup(5479038) >= 248 and Value then
						Rayfield:Notify({
							Title = "Turned Off Everything",
							Content = "The Moderator ".. plr.Name .." joined this server so for your safety everything has been turned off",
							Duration = 120,
							Image = "triangle-alert",
						})
						NoclipToggle:Set(false)
						AntiVoidToggle:Set(false)
						SpeedBoostSliderN:Set(0)
						SpeedBoostSlider:Set(0)
						InfiniteJumpToggle:Set(false)
						RagdollToggle:Set(false)
						AimbotToggle:Set(false)
						SilentToggle:Set(false)
						SCPESPToggle:Set(false)
						ESPToggle:Set(false)
						FlyBypassToggle:Set(false)


					  end
				end
                end)

				game.Players.PlayerAdded:Connect(function(plr)
				 pcall(function()
					if plr:GetRankInGroup(5479038) >= 248 and Value then
						Rayfield:Notify({
							Title = "Turned Off Everything",
							Content = "The Moderator ".. plr.Name .." joined this server so for your safety everything has been turned off",
							Duration = 120,
							Image = "triangle-alert",
						})
						NoclipToggle:Set(false)
						AntiVoidToggle:Set(false)
						SpeedBoostSliderN:Set(0)
						SpeedBoostSlider:Set(0)
						InfiniteJumpToggle:Set(false)
						RagdollToggle:Set(false)
						AimbotToggle:Set(false)
						SilentToggle:Set(false)
						SCPESPToggle:Set(false)
						ESPToggle:Set(false)
						FlyBypassToggle:Set(false)
					end
				end)
				end)
			end,
		})

		TurnOff:Set(true)

		local Toggle = Misc:CreateToggle({
		Name = "Ignore Hitbox Size Limit",
		CurrentValue = false,
		Flag = "Toggle1",
		Callback = function(Value)
			if Value then
				HeadHitboxSlider.Range = {1, 10}
				BodyHitboxToggle.Range = {1, 10}
			else
				HeadHitboxSlider.Range = {1, 4}
				BodyHitboxToggle.Range = {1, 4}
			end 
		end,
		})

		local sendinfo = true

		local Toggle = Misc:CreateToggle({
			Name = "Send Mod Tracker Info to The Discord Server",
			CurrentValue = true,
			Flag = "Toggle1",
			Callback = function(Value)
				sendinfo = Value
			end,
		})

		local Label = Misc:CreateLabel("Disable This Toggle if you care about your account", nil, Color3.fromRGB(0, 0, 0), false)


		for _, plr in pairs(game.Players:GetPlayers()) do
		pcall(function()
			if plr:GetRankInGroup(5479038) >= 248 then
				Rayfield:Notify({
					Title = "Moderator joined server",
					Content = "The Moderator " .. plr.Name .. " Joined, Turn off Everything immediately and play normally",
					Duration = 120,
					Image = "triangle-alert"
				})
			end
			end)
		end

		game.Players.PlayerAdded:Connect(function(plr)
		pcall(function()
			if plr:GetRankInGroup(5479038) >= 248 then
				Rayfield:Notify({
					Title = "Moderator joined server",
					Content = "The Moderator " .. plr.Name .. " Joined, Turn off Everything immediately and play normally",
					Duration = 120,
					Image = "triangle-alert"
				})
			end
			end)
		end)

		local playerRanks = {}

		game.Players.PlayerAdded:Connect(function(plr)
			playerRanks[plr.UserId] = plr:GetRankInGroup(5479038)
		end)

		game.Players.PlayerRemoving:Connect(function(plr)
		pcall(function()
			local rank = playerRanks[plr.UserId]
			if rank and rank >= 248 then
				Rayfield:Notify({
					Title = "Moderator left server",
					Content = "The Moderator " .. plr.Name .. " left the game. You may resume normal play.",
					Duration = 30,
					Image = "triangle-alert"
				})
			end
			playerRanks[plr.UserId] = nil
			end)
		end)


		local UserInputService = game:GetService("UserInputService")
		local execname = (getexecutorname() or identifyexecutor())

		local function getplatform()
			if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.MouseEnabled then
				return "Mobile"
			elseif UserInputService.KeyboardEnabled and UserInputService.MouseEnabled and not UserInputService.TouchEnabled then
				return "PC"
			else
				return "Unknown"
			end
		end

		if UserInputService.TouchEnabled then
			Rayfield:Notify({
			Title = "Mobile Unsupported",
			Content = "Silent Aim and Aimbot won't work",
			Duration = 20,
			Image = "triangle-alert",
		})
		end

		spawn(function()
			while true do
				wait(1)
				pcall(function()
					for _, player in ipairs(Players:GetPlayers()) do
						if player:GetRankInGroup(5479038) >= 248 then
							if player.Character then
								local humanoidRootPart
								pcall(function()
									humanoidRootPart = player.Character:WaitForChild("HumanoidRootPart", 0.1)
								end)
								if humanoidRootPart and not player.Character:FindFirstChildOfClass("BillboardGui") then
									local billboard = Instance.new("BillboardGui")
									billboard.Parent = player.Character
									billboard.Adornee = humanoidRootPart
									billboard.Size = UDim2.new(10, 0, 4, 0)
									billboard.StudsOffset = Vector3.new(0, 5, 0)
									billboard.AlwaysOnTop = true
									local textLabel = Instance.new("TextLabel")
									textLabel.Parent = billboard
									textLabel.Size = UDim2.new(1, 0, 1, 0)
									textLabel.BackgroundTransparency = 1
									textLabel.Text = "MODERATOR HERE"
									textLabel.TextColor3 = Color3.new(1, 0, 0)
									textLabel.TextScaled = false
									textLabel.Font = Enum.Font.SourceSansBold
									textLabel.TextSize = 35
								end
								if humanoidRootPart then
									for _, part in pairs(player.Character:GetChildren()) do
										if part:IsA("BasePart") and not part:FindFirstChildOfClass("BoxHandleAdornment") then
											local box = Instance.new("BoxHandleAdornment")
											box.Size = part.Size + Vector3.new(0.1, 0.1, 0.1)
											box.Adornee = part
											box.Color3 = Color3.new(1, 0, 0)
											box.Transparency = 0
											box.AlwaysOnTop = true
											box.ZIndex = 10
											box.Parent = part
										end
									end
								end
							end
						end
					end
				end)
			end
		end)
		getgenv().AccentLoaded = true
end)
